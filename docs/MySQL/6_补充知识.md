# 补充知识

## inner join、outer join 和 full jion

### 1. inner join（内连接）

返回两表中**连接字段**相等的记录。

### 2. outer join（外连接）

- left join（左外连接）

  返回左表中所有记录和右边中连接字段相等的记录。

- right join（右外连接）

  返回右表中所有记录和左边中连接字段相等的记录。

注意： 

```sql
-- Stu 表（10 条记录）
|-1-|-A-|
|-2-|-B-|
|-3-|-C-|
|-4-|-D-|
|-5-|-E-|
|-6-|-F-|
|-7-|-G-|
|-8-|-H-|
|-9-|-I-|
|-10-|-J-|

-- S 表（5 条记录）
|-1-|-B-|
|-2-|-B-|
|-3-|-B-|
|-4-|-B-|
|-5-|-B-|
```

```sql
SELECT stu.id,stu.name
FROM Stu stu
LEFT JOIN S s
ON stu.name=s.name;

# 返回 14 条记录
# 因为 jion 操作可能会有多条记录
```

### 3. full join（全连接）

返回两表中的所有记录和连接字段相等的记录。



## 子查询和 join 查询

- 子查询不一定需要 2 个表有关联字段；

  join 查询必须要求有关联字段

- 数据量比较大时，使用 join 查询寻性能会更好。（因为子查询走的是笛卡尔积）

- 子查询只有一条记录；

  join 查询可能会有多条记录

  所以将子查询转换为 join 查询时，要注意去重



## where 和 on

on 一般与 join 结合使用，使用 join 会产生临时表。

- on 是在生成临时表时使用的条件

- where 是在生成临时表后使用的条件

即 on 在 where 之前执行。



## where 和  having

- where

  是一个约束声明，在查询结果返回前对查询结果进行约束；

  where 后面不可以使用 “聚合函数”。

- having

  是一个过滤声明，在查询结果返回后对查询结果进行过滤；

  where 后面可以使用 “聚合函数”。



## order by 和 group by

功能上：

- order by 是用来排序，分为 desc 和 asc
- group by 是用来进行分组，并且可以和 "聚合函数" 一起使用

使用上：

group  by 在 order by 之前使用，即先进行分组，然后再进行排序。 

## drop、delete 与 truncate 

- drop（丢弃数据）: `drop table 表名` ，直接将表都删除掉，在删除表的时候使用。
- truncate (清除数据) : `truncate table 表名` ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。
- delete（删除数据） : `delete from 表名 where 列名=值`，删除某一列的数据，如果不加 where 子句和`truncate table 表名`作用类似。

truncate 和不带 where 子句的 delete、以及 drop 都会删除表内的数据，但是 truncate 和 delete 只删除数据不删除表的结构(定义)，执行 drop 语句，此表的结构也会删除，也就是执行 drop 之后对应的表不复存在。

## 查询顺序

select > from > where > group by > having > order by > limit



## 优先级

优先级：not > and > or 

可以使用 () 来改变优先级。



## 数据库备份

### 1. 备份方式

- 热备份：当数据库进行备份时，数据库的读写操作均不受影响
- 温备份：当数据库进行备份时，数据库的读操作可以进行，但不能执行写操作
- 冷备份：当数据库进行备份时，数据库不能进行读写操作

### 2. 备份策略

- 直接复制数据库文件

  针对数据量较小的场景。

- mysqldump + 复制 binlog

  针对数据量适中的场景。mysqldump 对数据库进行完全备份，定期备份 binlog 达到增量备份的效果。

  mysqldump 实际上就是讲表结构和数据存储在文本文件中，原理：先根据表结构生成 CREATE 语句，然后再将数据转换为 INSERT 语句

- ivm2 快照 + 复制 binlog

注：binlog 即二进制日志，记录对数据发生或者潜在发生更改的 SQL 语句，以二进制形式保存在文件中。

# 数据类型

## 整型

TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。

INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。

## 浮点数

FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。

FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。

## 字符串

主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。

VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。

在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。

## 时间和日期

MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。

### 1. DATETIME

能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。

它与时区无关。

默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。

### 2. TIMESTAMP

和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。

它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。

MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。

默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。

**应该尽量使用 TIMESTAMP**：

- DATETIME 类型与时区无关，即没有时区信息。当更换时区后，比如服务器更换地址或者更换客户端连接时区设置，就会导致从数据库中读出的时间错误。

  TIMESTAMP 类型和时区有关。TIMESTAMP 类型字段的值会随着服务器时区的变化而变化，自动换算成相应的时间

- TIMESTAMP 只需要使用 4 个字节的存储空间，但 DATETIME 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，TIMESTAMP 表示的时间范围更小。

  - DATETIME ：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59
  - TIMESTAMP： 1970-01-01 00:00:01 ~ 2037-12-31 23:59:59

  注意 5.6.4 之后的 MySQL 多出了一个需要 0 ～ 3 字节的小数位。DATETIME 和 TIMESTAMP 会有几种不同的存储空间占用。
